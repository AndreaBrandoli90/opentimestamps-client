#!/usr/bin/env python3
# Copyright (C) 2016 The OpenTimestamps developers
#
# This file is part of the OpenTimestamps Client.
#
# It is subject to the license terms in the LICENSE file found in the top-level
# directory of this distribution.
#
# No part of the OpenTimestamps Client, including this file, may be copied,
# modified, propagated, or distributed except according to the terms contained
# in the LICENSE file.

import sys


import argparse
import binascii
import datetime
import json
import logging
import os
import os.path
import sys
import time

import bitcoin
import bitcoin.rpc

from bitcoin.core import *

from opentimestamps.core.op import *
from opentimestamps.core.notary import *
from opentimestamps.core.timestamp import *
from opentimestamps.core.serialize import *
from opentimestamps.op import *
from opentimestamps.bitcoin import *

parser = argparse.ArgumentParser(description="Timestamp file converter")

parser.add_argument('file_fds', metavar='FILE', type=argparse.FileType('r+b'),
                    nargs='+',
                    help='Old timestamp files; converted in-place')

args = parser.parse_args()

proxy = bitcoin.rpc.Proxy()

for fd in args.file_fds:
    print('Converting %r' % fd.name)

    old_ts = json.loads(fd.read().decode('utf8'))

    old_path = old_ts[0]
    old_attestation = old_ts[1]


    target_filename = fd.name[:-4]
    target_fd = open(target_filename, 'rb')

    new_path = OpSHA256.from_fd(target_fd)
    prev_op = new_path
    for op_name, hex_prefix, hex_suffix in old_path[1:]:
        prefix = x(hex_prefix)
        suffix = x(hex_suffix)

        if prefix:
            prepend_op = OpPrepend(prefix, prev_op)
            prev_op.next_op = prepend_op
            prev_op = prev_op.next_op

        if suffix:
            append_op = OpAppend(prev_op, suffix)
            prev_op.next_op = append_op
            prev_op = prev_op.next_op

        if op_name == 'sha256':
            sha256_op = OpSHA256(prev_op)
            prev_op.next_op = sha256_op
        elif op_name == 'ripemd160':
            ripemd160_op = OpRIPEMD160(prev_op)
            prev_op.next_op = ripemd160_op
        elif op_name == 'reverse':
            reverse_op = OpReverse(prev_op)
            prev_op.next_op = reverse_op

        else:
            assert False

        prev_op = prev_op.next_op

    hdr_prefix = x(old_attestation[2])
    hdr_suffix = x(old_attestation[3])

    serialized_hdr = hdr_prefix + new_path.final_commitment() + hdr_suffix

    hdr = CBlockHeader.deserialize(serialized_hdr)

    r = proxy._call('getblock', b2lx(hdr.GetHash()), True)
    blk_height = r['height']

    print(b2lx(hdr.GetHash()), blk_height)

    btc_attestation = BitcoinBlockHeaderAttestation(blk_height)

    new_detached_timestamp = DetachedTimestampFile(Timestamp(new_path, btc_attestation))

    fd.truncate(0)
    fd.seek(0)

    ctx = StreamSerializationContext(fd)
    new_detached_timestamp.serialize(ctx)

# vim:syntax=python filetype=python
