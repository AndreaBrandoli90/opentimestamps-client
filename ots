#!/usr/bin/env python3
# Copyright (C) 2015 The python-opentimestamps developers
#
# This file is part of python-opentimestamps.
#
# It is subject to the license terms in the LICENSE file found in the top-level
# directory of this distribution.
#
# No part of python-bitcoinlib, including this file, may be copied, modified,
# propagated, or distributed except according to the terms contained in the
# LICENSE file.

import argparse
import datetime
import json
import logging
import os
import os.path

from binascii import hexlify

from opentimestamps.core.op import *
from opentimestamps.op import *
from opentimestamps.core.notary import *
from opentimestamps.core.timestamp import *
from opentimestamps.core.serialize import *

parser = argparse.ArgumentParser(description="OpenTimestamps client.")

parser.add_argument("-q", "--quiet", action="count", default=0,
                    help="Be more quiet.")
parser.add_argument("-v", "--verbose", action="count", default=0,
                    help="Be more verbose. Both -v and -q may be used multiple times.")

subparsers = parser.add_subparsers(title='Subcommands',
                                   description='All operations are done through subcommands:')

# ----- stamp -----
parser_stamp = subparsers.add_parser('stamp', aliases=['s'],
                                     help='Timestamp files')
parser_stamp.add_argument('--no-nonce', dest='use_nonce', action='store_false', default=True,
                          help='Do not use a nonce in the hash calculation. WARNING: may cause privacy loss!')
parser_stamp.add_argument('files', metavar='FILE', type=argparse.FileType('rb'),
                          nargs='+',
                          help='Filename')

# ----- upgrade -----
parser_upgrade = subparsers.add_parser('upgrade', aliases=['u'],
                                        help='Upgrade existing timestamps to better proof')
parser_upgrade.add_argument('files', metavar='FILE', type=argparse.FileType('r'),
                            nargs='+',
                            help='Filename')

# ----- verify -----
parser_verify = subparsers.add_parser('verify', aliases=['v'],
                                      help="Verify a timestamp")
parser_verify.add_argument('file', metavar='FILE', type=argparse.FileType('r'),
                           help='Filename')

# ----- info -----
parser_info = subparsers.add_parser('info', aliases=['u'],
                                        help='Show information on a timestamp')
parser_info.add_argument('file', metavar='FILE', type=argparse.FileType('rb'),
                            help='Filename')

def stamp_command(args):
    # Create initial commitment ops for all files
    file_op_paths = []
    for fd in args.files:
        # FIXME: handle file IO errors
        op = OpSHA256.from_fd(fd)
        file_op_paths.append(op)

    # Remember that the files - and their timestamps - might get separated
    # later, so if we didn't use a nonce for every file, the timestamp
    # would leak information on the digests of adjacent files.
    merkle_roots = [cat_sha256(file_op_path, os.urandom(16)) if args.use_nonce else file_op_path for file_op_path in file_op_paths]

    tip = make_merkle_tree(merkle_roots)

    time_attestation = PendingAttestation(b'https://btc.calendar.opentimestamps.org')

    for (in_file, file_op_path) in zip(args.files, file_op_paths):
        timestamp_file_path = in_file.name + '.ots'
        with open(timestamp_file_path, 'xb') as timestamp_fd:
            timestamp = Timestamp(file_op_path, time_attestation)
            detached_timestamp = DetachedTimestampFile(timestamp)

            #import pdb; pdb.set_trace()

            ctx = StreamSerializationContext(timestamp_fd)
            detached_timestamp.serialize(ctx)

parser_stamp.set_defaults(cmd_func=stamp_command)


def upgrade_command(args):
    pass

parser_upgrade.set_defaults(cmd_func=upgrade_command)


def verify_command(args):
    pass

parser_verify.set_defaults(cmd_func=verify_command)

def info_command(args):
    ctx = StreamDeserializationContext(args.file)
    detached_timestamp = DetachedTimestampFile.deserialize(ctx)

    print("File %s hash: %s" % (detached_timestamp.timestamp.path.HASHLIB_NAME, hexlify(detached_timestamp.timestamp.path.result).decode('utf8')))

    print("Path ops:")

    op = detached_timestamp.timestamp.path
    while op is not None:
        print('    ' + str(op))

        if args.verbosity > 0:
            print('-> %s' % hexlify(op.result).decode('utf8'))

        op = op.next_op

    print(detached_timestamp.timestamp.attestation)


parser_info.set_defaults(cmd_func=info_command)

args = parser.parse_args()
args.parser = parser

#args.proxy = bitcoin.rpc.Proxy()

args.verbosity = args.verbose - args.quiet

if args.verbosity == 0:
    logging.root.setLevel(logging.INFO)
elif args.verbosity > 0:
    logging.root.setLevel(logging.DEBUG)
elif args.verbosity == -1:
    logging.root.setLevel(logging.WARNING)
elif args.verbosity < -1:
    logging.root.setLevel(logging.ERROR)

if not hasattr(args, 'cmd_func'):
    parser.error('No command specified')

args.cmd_func(args)

# vim:syntax=python filetype=python
