#!/usr/bin/python3
# Copyright (C) 2012 Peter Todd <pete@petertodd.org>
#
# This file is part of the OpenTimestamps Client.
#
# It is subject to the license terms in the LICENSE file found in the top-level
# directory of this distribution and at http://opentimestamps.org
#
# No part of the OpenTimestamps Client, including this file, may be copied,
# modified, propagated, or distributed except according to the terms contained
# in the LICENSE file.

import sys

import argparse
import binascii
import datetime
import hashlib
import io
import json
import os

from opentimestamps._internal import FileManager
from opentimestamps.dag import *
from opentimestamps.io import *
from opentimestamps.notary import *
from opentimestamps.rpc import *
from opentimestamps.serialization import *

parser = argparse.ArgumentParser(description="OpenTimestamps client.")

def submit_command(args):
    if args.timestamp is None:
        if args.file is not '-':
            args.timestamp = args.file + '.ots'
        else:
            parser.error("Must specify timestamp file (or stdout) if input is stdin")

    if os.path.exists(args.timestamp):
        parser.error("file '%s' already exists" % args.timestamp)

    # Don't let the user overwrite the input
    if os.path.realpath(args.file) == os.path.realpath(args.timestamp):
        parser.error("timestamp would overwrite file")

    with FileManager(args.file,args.timestamp) as fm:
        file_digest = hashlib.sha256()
        file_digest.update(fm.in_fd.read())
        file_digest = file_digest.digest()

        hash_op = None
        if not args.no_nonce:
            nonce = os.urandom(hashlib.sha256().digest_size)
            hash_op = Hash(inputs=(file_digest,nonce))
        else:
            hash_op = Digest(digest=file_digest)

        responses = []
        for server in args.server:
            server = OtsServer(server)

            r = server.post_digest(op=hash_op)
            responses.extend(r)

        all_ops = responses
        all_ops.append(hash_op)

        timestamp_file = TimestampFile(ops=all_ops,out_fd=fm.out_fd)
        timestamp_file.write()

        fm.commit()

def sign_command(args):
    responses = []
    for server in args.server:
        server = OtsServer(server)

        notary = PGPNotary(identity=args.fingerprint)
        notary.canonicalize_identity()

        child = server.get_merkle_child(notary=notary)
        sig = notary.sign(child.digest,int(time.time()*1000000))

        verify_op = Verify(inputs=(child,),signature=sig)
        r = server.post_verification(verify_op=verify_op)

        responses.append(r)

        print('Signed digest %s for server %s' % (binascii.hexlify(child.digest),server.url))


def complete_command(args):
    with FileManager(args.timestamp,args.output) as fm:
        timestamp_file = TimestampFile(in_fd=fm.in_fd,out_fd=fm.out_fd)
        timestamp_file.read()

        new_ops = []
        for server in args.server:
            server = OtsServer(server)

            notary = PGPNotary(identity=args.fingerprint)
            notary.canonicalize_identity()

            for d in timestamp_file.ops:
                r = server.get_path(d,notary)
                if r is not None:
                    new_ops.extend(r)

        timestamp_file.ops.extend(new_ops)
        timestamp_file.write()
        fm.commit()

        print(json.dumps(json_serialize(timestamp_file.ops),indent=4))


def jsondump_command(args):
    with FileManager(args.timestamp,'-') as fm:
        timestamp_file = TimestampFile(in_fd=fm.in_fd,out_fd=None)
        timestamp_file.read()

        print(json.dumps(json_serialize(timestamp_file.options),indent=4))
        print(json.dumps(json_serialize(timestamp_file.ops),indent=4))


def verify_command(args):
    if args.timestamp is None:
        if args.file is not '-':
            args.timestamp = args.file + '.ots'
        else:
            parser.error("Must specify timestamp filename if input is stdin")

    with FileManager(args.file,'-') as fm_file,\
         FileManager(args.timestamp,'-') as fm_timestamp:

        file_digest = hashlib.sha256()
        file_digest.update(fm_file.in_fd.read())
        file_digest = file_digest.digest()

        dag = Dag()

        file_digest = Digest(file_digest)

        timestamp_file = TimestampFile(in_fd=fm_timestamp.in_fd,out_fd=None)
        timestamp_file.read()

        dag.update(timestamp_file.ops)

        successful_verification = False
        for v in dag.verifications:
            path = dag.path(file_digest,v)

            if path is not None:
                try:
                    v.signature.verify(v.inputs[0])
                except SignatureVerificationError as err:
                    print('BAD signature from %s:%s, got err %r' % \
                            (v.signature.notary.method,
                             v.signature.notary.identity,
                             err))
                    continue

                successful_verification = True
                timestamp = datetime.datetime.fromtimestamp(v.signature.timestamp / 1000000)
                print('GOOD signature from %s:%s with timestamp %s' % \
                        (v.signature.notary.method,
                         v.signature.notary.identity,
                         timestamp.isoformat(' ')))

        if not dag.verifications:
            print('No signatures found!')
        elif not successful_verification:
            print('No successful verifications!')


def getsourcecode_command(args):
    for server_url in args.server:
        server = OtsServer(server_url)

        sourcecode_url = server.get_sourcecode()

        print("%s - %s" % (server_url,sourcecode_url))


def server_command(args):
    for server_url in args.server:
        server = OtsServer(server_url)

        evald_rpc_args = [eval(rpc_arg) for rpc_arg in args.args]

        jsond_rpc_args = [json_serialize(rpc_arg) for rpc_arg in evald_rpc_args]

        json_response = getattr(server,args.rpc_function)(*jsond_rpc_args)

        # FIXME: where to print server url?
        json.dump(json_response,sys.stdout,indent=args.indent)

        print()


parser.add_argument("-q","--quiet",action="count",
                             help="Be more quiet.")
parser.add_argument("-v","--verbose",action="count",
                             help="Be more verbose. Both -v and -q may be used multiple times.")
parser.add_argument("-c","--config",action="store",default="~/.opentimestamps/config",
        help="Location of config file. Defaults to: ~/.opentimestamps/config")
parser.add_argument("-s","--server",action="append",
                             help="Specify a server. May be used multiple times.")

subparsers = parser.add_subparsers(title='Subcommands',
                                   description='All operations are done through subcommands:')

# ----- submit -----
parser_sign = subparsers.add_parser('sign',#aliases=['s'],
        help='Sign a calendar.')
parser_sign.set_defaults(cmd_func=sign_command)
parser_sign.add_argument("fingerprint",action="store",
        help="PGP fingerprint of the signing key")

# ----- submit -----
parser_submit = subparsers.add_parser('submit',#aliases=['s'],
        help='Submit a file to be timestamped.')
parser_submit.set_defaults(cmd_func=submit_command)
parser_submit.add_argument("--no-nonce",action="store_true",default=False,
        help="Don't use a nonce in the hash calculation. Note: this means that"\
        " the server knows what data you have submitted.")
parser_submit.add_argument("file",action="store",
        help="The file to timestamp. (or - for standard input)")
parser_submit.add_argument("timestamp",action="store",nargs='?',
        help="Optionally specify filename (or - for standard output) to write timestamp to. Required if"\
        " input is standard input. Defaults to <file>.ots")

# ----- complete -----
parser_complete = subparsers.add_parser('complete',#aliases=['x'],
        help='Complete a timestamp.')
parser_complete.set_defaults(cmd_func=complete_command)

parser_complete.add_argument("fingerprint",action="store",
        help="fingerprint")

parser_complete.add_argument("timestamp",action="store",
        help="Filename of timestamp to complete. (or - for standard input)")

parser_complete.add_argument("output",action="store",nargs='?',
        help="Write to this filename (or - for standard output) instead of modifying existing timestamp.")

# ----- jsondump -----
parser_jsondump = subparsers.add_parser('jsondump',#aliases=['x'],
        help='JSON dump a timestamp')
parser_jsondump.set_defaults(cmd_func=jsondump_command)

parser_jsondump.add_argument("timestamp",action="store",
        help="Filename (or - for standard input)")

# ----- verify -----
parser_verify = subparsers.add_parser('verify',#aliases=['v'], aliases not supported in 2.7!
        help="Verify a file's timestamp")
parser_verify.set_defaults(cmd_func=verify_command)

parser_verify.add_argument("file",action="store",
        help="File to verify (or - for standard input)")
parser_verify.add_argument("timestamp",action="store",nargs='?',
        help="Optionally specify filename of timestamp. Required if input is standard input.")

# ----- getsourcecode -----
parser_getsourcecode = subparsers.add_parser('getsourcecode',
        help='Ask the specified server(s) for where to obtain source code. (AGPL license compliance)')
parser_getsourcecode.set_defaults(cmd_func=getsourcecode_command)

# ----- server -----
parser_server = subparsers.add_parser('server',
        help='Submit an RPC command to the server(s)')
parser_server.set_defaults(cmd_func=server_command)

parser_server.add_argument("-i","--indent",action="store",default=4,type=int,
        help="Set the indent level in json.dump()")
parser_server.add_argument("rpc_function",action="store")
parser_server.add_argument("args",action="store",nargs='*')


args = parser.parse_args()

if not args.server:
    args.server = ['http://localhost:2302']

args.cmd_func(args)
