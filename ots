#!/usr/bin/python3
# Copyright (C) 2012 Peter Todd <pete@petertodd.org>
#
# This file is part of the OpenTimestamps Client.
#
# It is subject to the license terms in the LICENSE file found in the top-level
# directory of this distribution and at http://opentimestamps.org
#
# No part of the OpenTimestamps Client, including this file, may be copied,
# modified, propagated, or distributed except according to the terms contained
# in the LICENSE file.

import argparse
import binascii
import datetime
import hashlib
import io
import json
import logging
import os
import sys

from opentimestamps._internal import FileManager
from opentimestamps.dag import *
from opentimestamps.io import *
from opentimestamps.notary import *
from opentimestamps.rpc import *
from opentimestamps.serialization import *

parser = argparse.ArgumentParser(description="OpenTimestamps client.")

def submit_command(args):
    if args.timestamp is None:
        if args.file is not '-':
            args.timestamp = args.file + '.ots'
        else:
            parser.error("Must specify timestamp file (or stdout) if input is stdin")


    # Don't let the user overwrite the input
    if os.path.realpath(args.file) == os.path.realpath(args.timestamp):
        parser.error("timestamp would overwrite file")

    digests = {}
    with FileManager(args.file,'-') as file_fm:
        # Calculate the digest for our file
        file_digest = hashlib.sha256()
        file_digest.update(file_fm.in_fd.read())
        file_digest = file_digest.digest()
        digests['sha256'] = file_digest

        timestamp_file = None

        # If we're being asked to output to a file, the file may already exist.
        # If it's a valid timestamp file, for the file we've been asked to
        # timestamp, use it.
        timestamp_file_already_exists = os.path.exists(args.timestamp) and args.timestamp != '-'
        in_name = '-'
        if timestamp_file_already_exists:
            in_name = args.timestamp
        with FileManager(in_name,args.timestamp) as stamp_fm:
            timestamp_file = None

            if timestamp_file_already_exists:
                try:
                    timestamp_file = TimestampFile(digests=digests,
                                        in_fd=stamp_fm.in_fd,
                                        out_fd=stamp_fm.out_fd)
                except TimestampFile.CorruptTimestampError:
                    parser.error("output file %s already exists and is not a timestamp; will not overwrite" \
                            % args.timestamp)

                timestamp_file.read()
                logging.info("Submitting an existing timestamp again")
            else:
                timestamp_file = TimestampFile(digests=digests,out_fd=stamp_fm.out_fd)
                logging.info("Creating a new timestamp file")

            # FIXME: probably should have a --force option, so that submit in
            # the general case doesn't just submit again.
            hash_op = None
            if not args.no_nonce:
                nonce = os.urandom(hashlib.sha256().digest_size)
                hash_op = Hash(inputs=(file_digest,nonce))
            else:
                hash_op = Digest(digest=file_digest)

            server = OtsServer(args.server)

            timestamp_file.dag.update(server.post_digest(op=hash_op))

            if hash_op not in timestamp_file.dag:
                timestamp_file.dag.add(hash_op)

            timestamp_file.write()

            stamp_fm.commit()

            if args.verbosity > 0:
                logging.debug(json.dumps(json_serialize(tuple(dag)),indent=4))


def sign_command(args):
    server = OtsServer(args.server)

    notary = PGPNotary(identity=args.fingerprint)
    notary.canonicalize_identity()

    merkle_tip_ops = server.get_merkle_tip()
    logging.debug(json.dumps(json_serialize(merkle_tip_ops),indent=4))

    sig = notary.sign(merkle_tip_ops[-1].digest,int(time.time()*1000000))

    verify_op = Verify(inputs=(merkle_tip_ops[-1],),signature=sig)
    merkle_tip_ops.append(verify_op)
    r = server.post_verification(ops=merkle_tip_ops)


    logging.debug(json.dumps(json_serialize(r),indent=4))
    logging.info('Signed digest %s for server %s' %
            (binascii.hexlify(merkle_tip_ops[-2].digest),server.url))


def complete_command(args):
    with FileManager(args.timestamp,args.output) as fm:
        timestamp_file = TimestampFile(in_fd=fm.in_fd,out_fd=fm.out_fd)
        timestamp_file.read()

        new_ops = []
        old_ops = set(timestamp_file.dag)
        server = OtsServer(args.server)

        previous_verifications = set(timestamp_file.dag.verifications)
        for d in timestamp_file.dag:
            if args.server in d.metadata:
                r = server.get_path(op=d,notary_spec=args.notary)
                if r:
                    new_ops.extend(r)

        timestamp_file.dag.update(new_ops)

        new_verifications = set(timestamp_file.dag.verifications).difference(previous_verifications)
        if new_verifications:
            timestamp_file.write()
            fm.commit()

            new_ops = timestamp_file.dag.difference(old_ops)
            logging.debug("Got new ops from server:\n %s",json.dumps(json_serialize(new_ops),indent=4))

            for v in new_verifications:
                timestamp = datetime.datetime.fromtimestamp(v.signature.timestamp / 1000000)
                logging.info('New signature from %s:%s with timestamp %s' % \
                                 (v.signature.notary.method,
                                  v.signature.notary.identity,
                                  timestamp.isoformat(' ')))
        else:
            logging.info('No new signatures found.')


def jsondump_command(args):
    with FileManager(args.timestamp,'-') as fm:
        timestamp_file = TimestampFile(in_fd=fm.in_fd,out_fd=None)
        timestamp_file.read()

        print(json.dumps(json_serialize(timestamp_file.options),indent=4))
        print(json.dumps(json_serialize(tuple(timestamp_file.dag)),indent=4))


def verify_command(args):
    if args.timestamp is None:
        if args.file is not '-':
            args.timestamp = args.file + '.ots'
        else:
            parser.error("Must specify timestamp filename if input is stdin")

    with FileManager(args.file,'-') as fm_file,\
         FileManager(args.timestamp,'-') as fm_timestamp:

        digests = {}
        file_digest = hashlib.sha256()
        file_digest.update(fm_file.in_fd.read())
        file_digest = file_digest.digest()
        digests['sha256'] = file_digest

        timestamp_file = TimestampFile(digests=digests,in_fd=fm_timestamp.in_fd,out_fd=None)
        timestamp_file.read()

        successful_verification = False
        for v in timestamp_file.dag.verifications:
            path = timestamp_file.dag.path(file_digest,v)

            if path is not None:
                try:
                    v.signature.verify(v.inputs[0])
                except SignatureVerificationError as err:
                    logging.error('BAD signature from %s:%s, got err %r' % \
                                      (v.signature.notary.method,
                                       v.signature.notary.identity,
                                       err))
                    continue

                successful_verification = True
                timestamp = datetime.datetime.fromtimestamp(v.signature.timestamp / 1000000)
                logging.info('GOOD signature from %s:%s with timestamp %s' % \
                                 (v.signature.notary.method,
                                  v.signature.notary.identity,
                                  timestamp.isoformat(' ')))

        if not timestamp_file.dag.verifications:
            logging.error('No signatures found!')
        elif not successful_verification:
            logging.warn('No successful verifications!')


def getsourcecode_command(args):
    server = OtsServer(args.server)

    sourcecode_url = server.get_sourcecode()

    print("%s - %s" % (args.server,sourcecode_url))


parser.add_argument("-q","--quiet",action="count",default=0,
                             help="Be more quiet.")
parser.add_argument("-v","--verbose",action="count",default=0,
                             help="Be more verbose. Both -v and -q may be used multiple times.")
parser.add_argument("-c","--config",action="store",default="~/.opentimestamps/config",
        help="Location of config file. Defaults to: ~/.opentimestamps/config")
parser.add_argument("-s","--server",action="store",default="http://localhost:2302",
                             help="Specify the server.")

subparsers = parser.add_subparsers(title='Subcommands',
                                   description='All operations are done through subcommands:')

# ----- submit -----
parser_sign = subparsers.add_parser('sign',#aliases=['s'],
        help='Sign a calendar.')
parser_sign.set_defaults(cmd_func=sign_command)
parser_sign.add_argument("fingerprint",action="store",
        help="PGP fingerprint of the signing key")

# ----- submit -----
parser_submit = subparsers.add_parser('submit',#aliases=['s'],
        help='Submit a file to be timestamped.')
parser_submit.set_defaults(cmd_func=submit_command)
parser_submit.add_argument("--no-nonce",action="store_true",default=False,
        help="Don't use a nonce in the hash calculation. Note: this means that"\
        " the server knows what data you have submitted.")
parser_submit.add_argument("file",action="store",
        help="The file to timestamp. (or - for standard input)")
parser_submit.add_argument("timestamp",action="store",nargs='?',
        help="Optionally specify filename (or - for standard output) to write timestamp to. Required if"\
        " input is standard input. Defaults to <file>.ots")

# ----- complete -----
parser_complete = subparsers.add_parser('complete',#aliases=['x'],
        help='Complete a timestamp.')
parser_complete.set_defaults(cmd_func=complete_command)

parser_complete.add_argument("--notary",action="store",default="*:*",
        help="Notary to complete to")

parser_complete.add_argument("timestamp",action="store",
        help="Filename of timestamp to complete. (or - for standard input)")

parser_complete.add_argument("output",action="store",nargs='?',
        help="Write to this filename (or - for standard output) instead of modifying existing timestamp.")

# ----- jsondump -----
parser_jsondump = subparsers.add_parser('jsondump',#aliases=['x'],
        help='JSON dump a timestamp')
parser_jsondump.set_defaults(cmd_func=jsondump_command)

parser_jsondump.add_argument("timestamp",action="store",
        help="Filename (or - for standard input)")

# ----- verify -----
parser_verify = subparsers.add_parser('verify',#aliases=['v'], aliases not supported in 2.7!
        help="Verify a file's timestamp")
parser_verify.set_defaults(cmd_func=verify_command)

parser_verify.add_argument("file",action="store",
        help="File to verify (or - for standard input)")
parser_verify.add_argument("timestamp",action="store",nargs='?',
        help="Optionally specify filename of timestamp. Required if input is standard input.")

# ----- getsourcecode -----
parser_getsourcecode = subparsers.add_parser('getsourcecode',
        help='Ask the specified server(s) for where to obtain source code. (AGPL license compliance)')
parser_getsourcecode.set_defaults(cmd_func=getsourcecode_command)

args = parser.parse_args()

args.verbosity = args.verbose - args.quiet

if args.verbosity == 0:
    logging.root.setLevel(logging.INFO)
elif args.verbosity > 0:
    logging.root.setLevel(logging.DEBUG)
elif args.verbosity == -1:
    logging.root.setLevel(logging.WARNING)
elif args.verbosity < -1:
    logging.root.setLevel(logging.ERROR)

args.cmd_func(args)
